# Чирков Егор ИТ - 5 Лабораторная №5

# Задание 1
## Задача 1
### Текст задачи
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка
числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного
значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими
особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида “числитель/знаменатель”
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может
быть отрицательным.
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.
### Алгоритм решения
Создание интерфейса дроби:
Создаём интерфейс, который описывает, что должна уметь делать любая дробь: получать своё вещественное значение, 
устанавливать числитель и устанавливать знаменатель. Этот интерфейс — как договор, который подписывают все классы дробей.

Создание базовой дроби:
Создаём обычный класс дроби, который подписывает этот договор (реализует интерфейс). 
Дробь хранит два числа: числитель сверху и знаменатель снизу. Когда создаём новую дробь, проверяем, что знаменатель не ноль — иначе ошибка. 
Если знаменатель получился отрицательным, мы меняем знаки у обоих чисел, чтобы знаменатель всегда был положительным. При сравнении двух дробей считаем их одинаковыми, если совпадают и числитель, и знаменатель.

Создание умной дроби с кэшированием:
Создаём улучшенную версию дроби, которая умеет запоминать результат вычислений. 
Когда в первый раз просят вычислить вещественное значение, дробь выполняет деление и сохраняет результат в специальную память (кэш). 
При повторном запросе она просто возвращает сохранённое значение, не вычисляя заново. Но если дробь изменяется (меняют числитель или знаменатель), то сохранённое значение стирается, потому что оно уже неверное.
# Задание 2
## Задача 1
### Текст задачи
Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим
количество мяуканий на экран. Кота изменять нельзя.
Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со
следующей сигнатурой:
public void meow();
### Алгоритм решения
Создание интерфейса мяуканья:
Определяем, что значит "уметь мяукать". Любой объект, который может мяукать, должен иметь метод "мяукнуть". Это как общее правило для всех мяукающих существ.

Создание обычного кота:
Создаём класс кота, который умеет мяукать. Кот имеет имя, которое даётся при рождении и потом не меняется. Когда кот мяукает, он выводит на экран своё имя и слово "мяу!".
Создавать кота без имени нельзя — будет ошибка.

Создание кота-счётчика (декоратор):
Создаём специальную обёртку для кота, которая добавляет новую способность — подсчёт мяуканий. 
Эта обёртка выглядит и ведёт себя как обычный кот (тоже умеет мяукать), но внутри она содержит настоящего кота и счётчик. 
Каждый раз, когда просят мяукнуть, обёртка увеличивает счётчик на единицу, а затем просит настоящего кота мяукнуть. Так мы можем узнать, сколько раз мяукал кот, не изменяя сам класс кота.

Создание метода для группы мяукающих:
Создаём метод, который принимает целый список любых мяукающих объектов (и котов, и обёрток) и заставляет всех их мяукнуть по очереди.
# Задание 3
## Задача 1
### Текст задачи
Поиск максимума.
Составить программу, которая удаляет из списка L все элементы E, если такие есть.
### Алгоритм решения
Создание универсального метода удаления:
Создаём метод, который работает с любым типом данных в списке. 
Метод получает список и элемент, который нужно удалить. 
Метод проходит по всему списку от начала до конца и проверяет каждый элемент: если элемент совпадает с тем, который нужно удалить, он убирает его из списка. 
При этом используется специальный инструмент — итератор, который позволяет безопасно удалять элементы во время прохода по списку.

# Задание 4
## Задача 1
### Текст задачи
На вход программы подаются фамилии и имена учеников. Известно, что общее количество
учеников не превосходит 100. В первой строке вводится количество учеников, принимавших
участие в соревнованиях, N. Далее следуют N строк, имеющих следующий формат:
<Фамилия><Имя>
Здесь <Фамилия> – строка, состоящая не более чем из 20 символов; <Имя>– строка, состоящая не
более чем из 15 символов. При этом <Фамилия> и <Имя> разделены одним пробелом. Примеры
входных строк:
Иванова Мария
Петров Сергей
Требуется написать программу, которая формирует и печатает уникальный логин для каждого
ученика по следующему правилу: если фамилия встречается первый раз, то логин – это данная
фамилия, если фамилия встречается второй раз, то логин – это фамилия, в конец которой
приписывается число 2 и т.д. Например, для входной последовательности:
Иванова Мария
Петров Сергей
Бойцова Екатерина
Петров Иван
Иванова Наташа
будут сформированы следующие логины:
Иванова
Петров
Бойцова
Петров2
Иванова2
### Алгоритм решения
Чтение данных из файла:
Открываем текстовый файл и читаем его построчно. Каждая строка — это ученик в формате "Фамилия Имя". Проверяем, что фамилия не длиннее 20 символов, а имя не длиннее 15 символов. 
Также проверяем, что всего учеников не больше 100.

Подсчёт повторений фамилий:
Создаём специальный журнал, где отмечаем, сколько раз встречалась каждая фамилия. 
Проходим по всем ученикам: берём фамилию ученика, смотрим в журнал — если эта фамилия встречается впервые, записываем "1", если уже встречалась, увеличиваем счётчик.

Генерация логинов:
Для каждого ученика создаём логин по простому правилу: если фамилия встречается впервые — логин это просто фамилия, 
если фамилия встречается второй раз — к фамилии добавляем цифру 2, если третий раз — цифру 3, и так далее.

Пример работы:
Иванова Мария → Иванова (первая Иванова)
Петров Сергей → Петров (первый Петров)
Иванова Наташа → Иванова2 (вторая Иванова)
Петров Иван → Петров2 (второй Петров)

# Задание 5
## Задача 1
### Текст задачи
Файл содержит текст на русском языке. Напечатать в алфавитном порядке все звонкие
согласные буквы, которые входят хотя бы в одно слово.
### Алгоритм решения

Определение звонких согласных:
Создаём постоянный набор (коллекцию) всех звонких согласных букв русского алфавита: б, в, г, д, ж, з, й, л, м, н, р.

Чтение и подготовка текста:
Читаем весь текст из файла в одну большую строку. Приводим все буквы к нижнему регистру (маленькие), чтобы не было разницы между заглавными и строчными.

Разделение на слова:
Разбиваем текст на отдельные слова, убирая все пробелы, знаки препинания и другие не-буквенные символы.

Поиск согласных в словах:
Для каждого слова просматриваем все его буквы по очереди. 
Если буква находится в нашем наборе звонких согласных, добавляем её в результат. Используем специальную коллекцию, которая автоматически хранит только уникальные буквы и сортирует их по алфавиту.

Вывод результата:
Выводим все найденные звонкие согласные буквы в алфавитном порядке.

# Задание 6
## Задача 5
### Текст задачи
Переписать элементы из очереди L1 в очередь L2 в обратном порядке.
### Алгоритм решения
Использование стека как промежуточного хранилища:
Берём первую очередь (исходную) и временный стек. Стек работает по принципу "последний пришёл — первый ушёл".

Перекладывание из очереди в стек:
Достаём элементы из начала очереди по одному и кладём их в стек. Когда очередь станет пустой, все элементы окажутся в стеке, но в обратном порядке (тот, что был первым в очереди, теперь внизу стека).

Перекладывание из стека в новую очередь:
Достаём элементы из стека (начинаем с верхнего) и кладём их в новую очередь. Поскольку стек хранит элементы в обратном порядке, в новой очереди они расположатся в обратном порядке относительно исходной.

Результат:
Первая очередь становится пустой, вторая очередь содержит те же элементы, но в обратном порядке.

# Задание 7
## Задача 1
### Текст задачи
Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с
одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это
все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
• Координата Х: число.
• Координата Y: число.
• Может возвращать текстовое представление вида “{X;Y}”.
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
• Координата начала: Точка
• Координата конца: Точка
• Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная
линия представляет собой набор следующих характеристик:
• Имеет массив Точек, через которые линия проходит.
• Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это
результат приведения к строке Точки с номером N
### Алгоритм решения
Часть 1 — Создание геометрических классов

Точка:
Создаём класс, который представляет точку на плоскости с координатами X и Y. Точка после создания не может изменяться. Две точки считаются одинаковыми, если у них совпадают обе координаты.

Линия:
Создаём класс линии между двумя точками. Линия имеет начальную и конечную точки.

Ломаная линия:
Создаём класс ломаной линии, которая представляет собой последовательность точек, соединённых отрезками. Ломаная хранит список точек, через которые проходит.

Часть 2 — Обработка точек с помощью Stream API

Удаление одинаковых точек:
Берём список точек и убираем все точки с одинаковыми координатами, оставляя только уникальные.

Сортировка по координате X:
Сортируем оставшиеся точки по возрастанию координаты X (слева направо).

Преобразование координат:
Для каждой точки проверяем координату Y — если она отрицательная, делаем её положительной (берём модуль).

Сбор в ломаную:
Собираем обработанные точки в ломаную линию.

# Задание 7
## Задача 2
### Текст задачи
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
Вася:5
Петя:3
Аня:5
Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются
по их номеру:
[5:[Вася, Аня], 3:[Петя]]
### Алгоритм решения
Чтение и фильтрация:
Читаем все строки из файла и оставляем только те, которые содержат двоеточие (признак наличия номера).

Разбор строк:
Каждую строку разбиваем на две части по двоеточию: имя (левая часть) и номер (правая часть). Если имя пустое или номер пустой — пропускаем эту строку.

Форматирование имени:
Приводим имя к правильному формату: первая буква заглавная, остальные строчные.

Проверка номера:
Пытаемся преобразовать номер в число. Если не получается (например, номер содержит буквы) — пропускаем строку.

Группировка по номерам:
Собираем все имена в группы по их номерам. Получаем структуру, где каждому номеру соответствует список имён людей с этим номером.
